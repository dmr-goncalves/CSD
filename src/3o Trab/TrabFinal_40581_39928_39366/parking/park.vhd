-- Net park - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;
Use IEEE.NUMERIC_STD.ALL;

Entity park IS
Port(
    Clk : IN STD_LOGIC;
	 
	 button1 : IN STD_LOGIC;
	 button2 : IN STD_LOGIC;
	 switchFloor : IN STD_LOGIC;
	 switchIO : IN STD_LOGIC;
	 switchRamp : IN STD_LOGIC;
	 sensorA : IN STD_LOGIC;
	 sensorB : IN STD_LOGIC;

    gateOpenIn1 : OUT STD_LOGIC;
    gateOpenOutFloor1 : OUT STD_LOGIC;
    gateOpenIn2 : OUT STD_LOGIC;
    gateOpenOutFloor2 : OUT STD_LOGIC;
    FreeSpacesTotal : OUT INTEGER RANGE 0 TO 71;
    TotalCarsFloor1 : OUT INTEGER RANGE 0 TO 71;
    TotalCarsFloor2 : OUT INTEGER RANGE 0 TO 71;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC;
	 
	 --DEFINE
	 FreeSpacesAlgFloor1_1 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 FreeSpacesAlgFloor1_2 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 FreeSpacesAlgFloor2_1 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 FreeSpacesAlgFloor2_2 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 FreeSpacesAlgTotal_1 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 FreeSpacesAlgTotal_2 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 OccupiedSpacesAlgFloor1_1 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 OccupiedSpacesAlgFloor1_2 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 OccupiedSpacesAlgFloor2_1 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 OccupiedSpacesAlgFloor2_2 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 OccupiedSpacesAlgTotal_1 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 OccupiedSpacesAlgTotal_2 : OUT STD_LOGIC_VECTOR (3 downto 0);
	 LEDS : OUT STD_LOGIC_VECTOR (7 downto 0)
	 --
);
End park;

Architecture Structural OF park IS

    Signal p_2: INTEGER RANGE 0 TO 1 := 1;
    Signal p_3: INTEGER RANGE 0 TO 1 := 0;
    Signal p_4: INTEGER RANGE 0 TO 1 := 0;
    Signal p_14: INTEGER RANGE 0 TO 1 := 1;
    Signal p_15: INTEGER RANGE 0 TO 1 := 0;
    Signal p_16: INTEGER RANGE 0 TO 1 := 0;
    Signal p_33: INTEGER RANGE 0 TO 1 := 1;
    Signal p_34: INTEGER RANGE 0 TO 1 := 0;
    Signal p_35: INTEGER RANGE 0 TO 1 := 0;
    Signal p_63: INTEGER RANGE 0 TO 71 := 71;
    Signal p_79: INTEGER RANGE 0 TO 1 := 1;
    Signal p_80: INTEGER RANGE 0 TO 1 := 0;
    Signal p_81: INTEGER RANGE 0 TO 1 := 0;
    Signal p_136: INTEGER RANGE 0 TO 1 := 0;
    Signal p_137: INTEGER RANGE 0 TO 1 := 0;
    Signal p_151: INTEGER RANGE 0 TO 1 := 0;
    Signal p_152: INTEGER RANGE 0 TO 1 := 0;
    Signal p_167: INTEGER RANGE 0 TO 71 := 0;
    Signal p_172: INTEGER RANGE 0 TO 1 := 0;
    Signal p_188: INTEGER RANGE 0 TO 1 := 0;
    Signal p_212: INTEGER RANGE 0 TO 71 := 0;
	 
	 --DEFINE
	 Signal s_FreeCarsFloor1: INTEGER RANGE 0 TO 20 := 20;
	 Signal s_FreeCarsFloor2: INTEGER RANGE 0 TO 51 := 51;
	 Signal s_OccupiedSpacesTotal: INTEGER RANGE 0 TO 71 := 0;
	 
	 Signal s_FreeSpacesAlgFloor1_1 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_FreeSpacesAlgFloor1_2 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_FreeSpacesAlgFloor2_1 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_FreeSpacesAlgFloor2_2 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_FreeSpacesAlgTotal_1 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_FreeSpacesAlgTotal_2 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_OccupiedSpacesAlgFloor1_1 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_OccupiedSpacesAlgFloor1_2 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_OccupiedSpacesAlgFloor2_1 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_OccupiedSpacesAlgFloor2_2 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_OccupiedSpacesAlgTotal_1 : STD_LOGIC_VECTOR (3 downto 0);
	 Signal s_OccupiedSpacesAlgTotal_2 : STD_LOGIC_VECTOR (3 downto 0);
	 --

    Signal prev_arriveIn: STD_LOGIC := '0';
    Signal prev_arriveOutFloor1: STD_LOGIC := '0';
    Signal prev_rampUP: STD_LOGIC := '0';
    Signal prev_rampDOWN: STD_LOGIC := '0';
    Signal prev_arriveIn2: STD_LOGIC := '0';
    Signal prev_arriveOutFloor2: STD_LOGIC := '0';
    Signal prev_rampUPSensor2: STD_LOGIC := '0';
    Signal prev_rampDOWNSensor2: STD_LOGIC := '0';

    Signal event_arriveIn_PLUS: STD_LOGIC := '0';
    Signal event_arriveIn_MINUS: STD_LOGIC := '0';
    Signal event_arriveOutFloor1_Plus: STD_LOGIC := '0';
    Signal event_arriveOutFloor1_MINUS: STD_LOGIC := '0';
    Signal event_arriveIn2_PLUS: STD_LOGIC := '0';
    Signal event_arriveIn2_MINUS: STD_LOGIC := '0';
    Signal event_arriveOutFloor2_Plus: STD_LOGIC := '0';
    Signal event_arriveOutFloor2_MINUS: STD_LOGIC := '0';
    Signal event_rampUP_PLUS: STD_LOGIC := '0';
    Signal event_rampUP_MINUS: STD_LOGIC := '0';
    Signal event_rampDOWN_PLUS: STD_LOGIC := '0';
    Signal event_rampDOWN_MINUS: STD_LOGIC := '0';
    Signal event_rampUPSensor2_PLUS: STD_LOGIC := '0';
    Signal event_rampUPSensor2_MINUS: STD_LOGIC := '0';
    Signal event_rampDOWNSensor2_PLUS: STD_LOGIC := '0';
    Signal event_rampDOWNSensor2_MINUS: STD_LOGIC := '0';

    Signal s_gateOpenIn1 : STD_LOGIC := '0';
    Signal s_gateOpenOutFloor1 : STD_LOGIC := '0';
    Signal s_gateOpenIn2 : STD_LOGIC := '0';
    Signal s_gateOpenOutFloor2 : STD_LOGIC := '0';
    Signal s_FreeSpacesTotal : INTEGER RANGE 0 TO 71 := 71;
    Signal s_TotalCarsFloor1 : INTEGER RANGE 0 TO 71 := 0;
    Signal s_TotalCarsFloor2 : INTEGER RANGE 0 TO 71 := 0;

	 --DEFINE
	 Signal std_vector6 : std_logic_vector(7 downto 0);
	 Signal std_vector1 : std_logic_vector(7 downto 0);
	 Signal std_vector2 : std_logic_vector(7 downto 0);
	 Signal std_vector3 : std_logic_vector(7 downto 0);
	 Signal std_vector4 : std_logic_vector(7 downto 0);
	 Signal std_vector5 : std_logic_vector(7 downto 0);
	 Signal bcd6 : std_logic_vector(11 downto 0);
	 Signal bcd1 : std_logic_vector(11 downto 0);
	 Signal bcd2 : std_logic_vector(11 downto 0);
	 Signal bcd3 : std_logic_vector(11 downto 0);
	 Signal bcd4 : std_logic_vector(11 downto 0);
	 Signal bcd5 : std_logic_vector(11 downto 0);
	 
	 Signal s_arriveIn : STD_LOGIC;
    Signal s_arriveOutFloor1 : STD_LOGIC;
    Signal s_gotTicket1 : STD_LOGIC;
    Signal s_payFloor1 : STD_LOGIC;
    Signal s_rampUP : STD_LOGIC;
    Signal s_rampDOWN : STD_LOGIC;
    Signal s_payFloor2 : STD_LOGIC;
    Signal s_gotTicket2 : STD_LOGIC;
    Signal s_arriveIn2 : STD_LOGIC;
    Signal s_arriveOutFloor2 : STD_LOGIC;
    Signal s_rampUPSensor2 : STD_LOGIC;
    Signal s_rampDOWNSensor2 : STD_LOGIC;
	 --
    -- Array implementation:

function to_bcd ( bin : std_logic_vector(7 downto 0) ) return std_logic_vector is
	variable i : integer:=0;
	variable bcd : std_logic_vector(11 downto 0) := (others => '0');
	variable bint : std_logic_vector(7 downto 0) := bin;

	begin
	for i in 0 to 7 loop  -- repeating 8 times.
		bcd(11 downto 1) := bcd(10 downto 0);  --shifting the bits.
		bcd(0) := bint(7);
		bint(7 downto 1) := bint(6 downto 0);
		bint(0) :='0';

		if(i < 7 and bcd(3 downto 0) > "0100") then --add 3 if BCD digit is greater than 4.
			bcd(3 downto 0) := bcd(3 downto 0) + "0011";
		end if;

		if(i < 7 and bcd(7 downto 4) > "0100") then --add 3 if BCD digit is greater than 4.
			bcd(7 downto 4) := bcd(7 downto 4) + "0011";
		end if;

		if(i < 7 and bcd(11 downto 8) > "0100") then  --add 3 if BCD digit is greater than 4.
			bcd(11 downto 8) := bcd(11 downto 8) + "0011";
		end if;
	end loop;
	
	return bcd;
end to_bcd;

Begin

	process (Clk, Enable)
	begin
		if rising_edge(Clk) then
			if switchFloor = '0' and switchIO = '0' then
				if button1 = '1' then
					s_arriveIn <= '1';
				elsif button1 = '0' then
					s_arriveIn <= '0';
				end if;
				
				if button2 = '1' then
					s_gotTicket1 <= '1';
				elsif button2 = '0' then
					s_gotTicket1 <= '0';
				end if;
			end if;
			
			if switchFloor = '1' and switchIO = '0' then
				if button1 = '1' then
					s_arriveIn2 <= '1';
				elsif button1 = '0' then
					s_arriveIn2 <= '0';
				end if;
				
				if button2 = '1' then
					s_gotTicket2 <= '1';
				elsif button2 = '0' then
					s_gotTicket2 <= '0';
				end if;
			end if;
			
			if switchFloor = '0' and switchIO = '1' then
				if button1 = '1' then
					s_arriveOutFloor1 <= '1';
				elsif button1 = '0' then
					s_arriveOutFloor1 <= '0';
				end if;
				
				if button2 = '1' then
					s_payFloor1 <= '1';
				elsif button2 = '0' then
					s_payFloor1 <= '0';
				end if;
			end if;
			
			if switchFloor = '1' and switchIO = '1' then
				if button1 = '1' then
					s_arriveOutFloor2 <= '1';
				elsif button1 = '0' then
					s_arriveOutFloor2 <= '0';
				end if;
				
				if button2 = '1' then
					s_payFloor2 <= '1';
				elsif button2 = '0' then
					s_payFloor2 <= '0';
				end if;
			end if;
			
			if switchRamp = '0' then
				if sensorA = '1' then
					s_rampUP <= '1';
				elsif sensorA = '0' then
					s_rampUP <= '0';
				end if;
				
				if sensorB = '1' then
					s_rampUPSensor2 <= '1';
				elsif sensorB = '0' then
					s_rampUPSensor2 <= '0';
				end if;
			end if;
			
			if switchRamp = '1' then
				if sensorA = '1' then
					s_rampDOWN <= '1';
				elsif sensorA = '0' then
					s_rampDOWN <= '0';
				end if;
				
				if sensorB = '1' then
					s_rampDOWNSensor2 <= '1';
				elsif sensorB = '0' then
					s_rampDOWNSensor2 <= '0';
				end if;
			end if;
		end if;
	end process;
	
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
          If (prev_arriveIn = '0') and (s_arriveIn = '1')
            Then event_arriveIn_PLUS <= '1';
            Else event_arriveIn_PLUS <= '0';
          End If;
          If (prev_arriveIn = '1') and (s_arriveIn = '0')
            Then event_arriveIn_MINUS <= '1';
            Else event_arriveIn_MINUS <= '0';
          End If;
          If (prev_arriveOutFloor1 = '0') and (s_arriveOutFloor1 = '1')
            Then event_arriveOutFloor1_Plus <= '1';
            Else event_arriveOutFloor1_Plus <= '0';
          End If;
          If (prev_arriveOutFloor1 = '1') and (s_arriveOutFloor1 = '0')
            Then event_arriveOutFloor1_MINUS <= '1';
            Else event_arriveOutFloor1_MINUS <= '0';
          End If;
          If (prev_arriveIn2 = '0') and (s_arriveIn2 = '1')
            Then event_arriveIn2_PLUS <= '1';
            Else event_arriveIn2_PLUS <= '0';
          End If;
          If (prev_arriveIn2 = '1') and (s_arriveIn2 = '0')
            Then event_arriveIn2_MINUS <= '1';
            Else event_arriveIn2_MINUS <= '0';
          End If;
          If (prev_arriveOutFloor2 = '0') and (s_arriveOutFloor2 = '1')
            Then event_arriveOutFloor2_Plus <= '1';
            Else event_arriveOutFloor2_Plus <= '0';
          End If;
          If (prev_arriveOutFloor2 = '1') and (s_arriveOutFloor2 = '0')
            Then event_arriveOutFloor2_MINUS <= '1';
            Else event_arriveOutFloor2_MINUS <= '0';
          End If;
          If (prev_rampUP = '0') and (s_rampUP = '1')
            Then event_rampUP_PLUS <= '1';
            Else event_rampUP_PLUS <= '0';
          End If;
          If (prev_rampUP = '1') and (s_rampUP = '0')
            Then event_rampUP_MINUS <= '1';
            Else event_rampUP_MINUS <= '0';
          End If;
          If (prev_rampDOWN = '0') and (s_rampDOWN = '1')
            Then event_rampDOWN_PLUS <= '1';
            Else event_rampDOWN_PLUS <= '0';
          End If;
          If (prev_rampDOWN = '1') and (s_rampDOWN = '0')
            Then event_rampDOWN_MINUS <= '1';
            Else event_rampDOWN_MINUS <= '0';
          End If;
          If (prev_rampUPSensor2 = '0') and (s_rampUPSensor2 = '1')
            Then event_rampUPSensor2_PLUS <= '1';
            Else event_rampUPSensor2_PLUS <= '0';
          End If;
          If (prev_rampUPSensor2 = '1') and (s_rampUPSensor2 = '0')
            Then event_rampUPSensor2_MINUS <= '1';
            Else event_rampUPSensor2_MINUS <= '0';
          End If;
          If (prev_rampDOWNSensor2 = '0') and (s_rampDOWNSensor2 = '1')
            Then event_rampDOWNSensor2_PLUS <= '1';
            Else event_rampDOWNSensor2_PLUS <= '0';
          End If;
          If (prev_rampDOWNSensor2 = '1') and (s_rampDOWNSensor2 = '0')
            Then event_rampDOWNSensor2_MINUS <= '1';
            Else event_rampDOWNSensor2_MINUS <= '0';
          End If;
        End If;
        prev_arriveIn <= s_arriveIn;
        prev_arriveOutFloor1 <= s_arriveOutFloor1;
        prev_rampUP <= s_rampUP;
        prev_rampDOWN <= s_rampDOWN;
        prev_arriveIn2 <= s_arriveIn2;
        prev_arriveOutFloor2 <= s_arriveOutFloor2;
        prev_rampUPSensor2 <= s_rampUPSensor2;
        prev_rampDOWNSensor2 <= s_rampDOWNSensor2;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_2_add, p_2_avail : INTEGER RANGE 0 to 1;
      Variable p_3_add, p_3_avail : INTEGER RANGE 0 to 1;
      Variable p_4_add, p_4_avail : INTEGER RANGE 0 to 1;
      Variable p_14_add, p_14_avail : INTEGER RANGE 0 to 1;
      Variable p_15_add, p_15_avail : INTEGER RANGE 0 to 1;
      Variable p_16_add, p_16_avail : INTEGER RANGE 0 to 1;
      Variable p_33_add, p_33_avail : INTEGER RANGE 0 to 1;
      Variable p_34_add, p_34_avail : INTEGER RANGE 0 to 1;
      Variable p_35_add, p_35_avail : INTEGER RANGE 0 to 1;
      Variable p_63_add, p_63_avail : INTEGER RANGE 0 to 71;
      Variable p_79_add, p_79_avail : INTEGER RANGE 0 to 1;
      Variable p_80_add, p_80_avail : INTEGER RANGE 0 to 1;
      Variable p_81_add, p_81_avail : INTEGER RANGE 0 to 1;
      Variable p_136_add, p_136_avail : INTEGER RANGE 0 to 1;
      Variable p_137_add, p_137_avail : INTEGER RANGE 0 to 1;
      Variable p_151_add, p_151_avail : INTEGER RANGE 0 to 1;
      Variable p_152_add, p_152_avail : INTEGER RANGE 0 to 1;
      Variable p_167_add, p_167_avail : INTEGER RANGE 0 to 71;
      Variable p_172_add, p_172_avail : INTEGER RANGE 0 to 1;
      Variable p_188_add, p_188_avail : INTEGER RANGE 0 to 1;
      Variable p_212_add, p_212_avail : INTEGER RANGE 0 to 71;
    Begin
      If Reset = '1' Then
          p_2 <= 1;
          p_3 <= 0;
          p_4 <= 0;
          p_14 <= 1;
          p_15 <= 0;
          p_16 <= 0;
          p_33 <= 1;
          p_34 <= 0;
          p_35 <= 0;
          p_63 <= 71;
          p_79 <= 1;
          p_80 <= 0;
          p_81 <= 0;
          p_136 <= 0;
          p_137 <= 0;
          p_151 <= 0;
          p_152 <= 0;
          p_167 <= 0;
          p_172 <= 0;
          p_188 <= 0;
          p_212 <= 0;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_2_avail := p_2;
          p_2_add := 0;   -- pl_2;
          p_3_avail := p_3;
          p_3_add := 0;   -- pl_3;
          p_4_avail := p_4;
          p_4_add := 0;   -- pl_4;
          p_14_avail := p_14;
          p_14_add := 0;   -- pl_2_2;
          p_15_avail := p_15;
          p_15_add := 0;   -- pl_3_2;
          p_16_avail := p_16;
          p_16_add := 0;   -- pl_4_2;
          p_33_avail := p_33;
          p_33_add := 0;   -- pl_2_3;
          p_34_avail := p_34;
          p_34_add := 0;   -- pl_3_3;
          p_35_avail := p_35;
          p_35_add := 0;   -- pl_4_3;
          p_63_avail := p_63;
          p_63_add := 0;   -- pl_26_2;
          p_79_avail := p_79;
          p_79_add := 0;   -- pl_2_2_2;
          p_80_avail := p_80;
          p_80_add := 0;   -- pl_3_2_2;
          p_81_avail := p_81;
          p_81_add := 0;   -- pl_4_2_2;
          p_136_avail := p_136;
          p_136_add := 0;   -- pl_136;
          p_137_avail := p_137;
          p_137_add := 0;   -- pl_137;
          p_151_avail := p_151;
          p_151_add := 0;   -- pl_136_2;
          p_152_avail := p_152;
          p_152_add := 0;   -- pl_137_2;
          p_167_avail := p_167;
          p_167_add := 0;   -- pl_167;
          p_172_avail := p_172;
          p_172_add := 0;   -- pl_172;
          p_188_avail := p_188;
          p_188_add := 0;   -- pl_188;
          p_212_avail := p_212;
          p_212_add := 0;   -- pl_212;


          -- Transition 5 - tr_5
          If (p_2_avail >= 1) and
             (event_arriveIn2_PLUS = '1')
          Then
              p_2_avail := p_2_avail - 1;    -- pl_2
              p_3_add := p_3_add + 1;   -- pl_3
          End If;

          -- Transition 7 - tr_7
          If (p_4_avail >= 1) and
             (event_arriveIn2_MINUS = '1')
          Then
              p_4_avail := p_4_avail - 1;    -- pl_4
              p_2_add := p_2_add + 1;   -- pl_2
          End If;

          -- Transition 17 - tr_5_2
          If (p_14_avail >= 1) and
             (event_arriveOutFloor2_Plus = '1')
          Then
              p_14_avail := p_14_avail - 1;    -- pl_2_2
              p_15_add := p_15_add + 1;   -- pl_3_2
          End If;

          -- Transition 18 - tr_6_2
          If (p_15_avail >= 1) and
             (p_212_avail >= 1) and 
             (conv_integer(s_payFloor2) = 1) -- guard expr 
          Then
              p_15_avail := p_15_avail - 1;    -- pl_3_2
              p_212_avail := p_212_avail - 1;    -- pl_212
              p_16_add := p_16_add + 1;   -- pl_4_2
              p_63_add := p_63_add + 1;   -- pl_26_2
          End If;

          -- Transition 19 - tr_7_2
          If (p_16_avail >= 1) and
             (event_arriveOutFloor2_MINUS = '1')
          Then
              p_16_avail := p_16_avail - 1;    -- pl_4_2
              p_14_add := p_14_add + 1;   -- pl_2_2
          End If;

          -- Transition 36 - tr_5_3
          If (p_33_avail >= 1) and
             (event_arriveIn_PLUS = '1')
          Then
              p_33_avail := p_33_avail - 1;    -- pl_2_3
              p_34_add := p_34_add + 1;   -- pl_3_3
          End If;

          -- Transition 37 - tr_6_3
          If (p_34_avail >= 1) and
             (p_63_avail >= 1) and 
             (conv_integer(s_gotTicket1) = 1) -- guard expr 
          Then
              p_34_avail := p_34_avail - 1;    -- pl_3_3
              p_63_avail := p_63_avail - 1;    -- pl_26_2
              p_35_add := p_35_add + 1;   -- pl_4_3
              p_167_add := p_167_add + 1;   -- pl_167
          End If;

          -- Transition 38 - tr_7_3
          If (p_35_avail >= 1) and
             (event_arriveIn_MINUS = '1')
          Then
              p_35_avail := p_35_avail - 1;    -- pl_4_3
              p_33_add := p_33_add + 1;   -- pl_2_3
          End If;

          -- Transition 82 - tr_5_2_2
          If (p_79_avail >= 1) and
             (event_arriveOutFloor1_Plus = '1')
          Then
              p_79_avail := p_79_avail - 1;    -- pl_2_2_2
              p_80_add := p_80_add + 1;   -- pl_3_2_2
          End If;

          -- Transition 83 - tr_6_2_2
          If (p_80_avail >= 1) and
             (p_167_avail >= 1) and 
             (conv_integer(s_payFloor1) = 1) -- guard expr 
          Then
              p_80_avail := p_80_avail - 1;    -- pl_3_2_2
              p_167_avail := p_167_avail - 1;    -- pl_167
              p_81_add := p_81_add + 1;   -- pl_4_2_2
              p_63_add := p_63_add + 1;   -- pl_26_2
          End If;

          -- Transition 84 - tr_7_2_2
          If (p_81_avail >= 1) and
             (event_arriveOutFloor1_MINUS = '1')
          Then
              p_81_avail := p_81_avail - 1;    -- pl_4_2_2
              p_79_add := p_79_add + 1;   -- pl_2_2_2
          End If;

          -- Transition 112 - tr_112
          If (p_137_avail >= 1) and
             (event_rampUP_MINUS = '1') and 
             (conv_integer(s_rampUPSensor2) = 1) -- guard expr 
          Then
              p_137_avail := p_137_avail - 1;    -- pl_137
              p_172_add := p_172_add + 1;   -- pl_172
          End If;

          -- Transition 132 - tr_132
          If (p_167_avail >= 1) and
             (event_rampUP_PLUS = '1') and 
             (p_136 = 0 AND p_137 = 0 AND p_172 = 0) -- guard expr 
          Then
              p_167_avail := p_167_avail - 1;    -- pl_167
              p_136_add := p_136_add + 1;   -- pl_136
          End If;

          -- Transition 134 - tr_134
          If (p_136_avail >= 1) and
             (event_rampUPSensor2_PLUS = '1') and 
             (conv_integer(s_rampUP) = 1) -- guard expr 
          Then
              p_136_avail := p_136_avail - 1;    -- pl_136
              p_137_add := p_137_add + 1;   -- pl_137
          End If;

          -- Transition 135 - tr_135
          If (p_137_avail >= 1) and
             (event_rampUPSensor2_MINUS = '1')
          Then
              p_137_avail := p_137_avail - 1;    -- pl_137
              p_136_add := p_136_add + 1;   -- pl_136
          End If;

          -- Transition 147 - tr_132_2
          If (p_212_avail >= 1) and
             (event_rampDOWN_PLUS = '1') and 
             (p_151 = 0 AND p_152 = 0 AND p_188 = 0) -- guard expr 
          Then
              p_212_avail := p_212_avail - 1;    -- pl_212
              p_151_add := p_151_add + 1;   -- pl_136_2
          End If;

          -- Transition 149 - tr_134_2
          If (p_151_avail >= 1) and
             (event_rampDOWNSensor2_PLUS = '1') and 
             (conv_integer(s_rampDOWN) = 1) -- guard expr 
          Then
              p_151_avail := p_151_avail - 1;    -- pl_136_2
              p_152_add := p_152_add + 1;   -- pl_137_2
          End If;

          -- Transition 150 - tr_135_2
          If (p_152_avail >= 1) and
             (event_rampDOWNSensor2_MINUS = '1')
          Then
              p_152_avail := p_152_avail - 1;    -- pl_137_2
              p_151_add := p_151_add + 1;   -- pl_136_2
          End If;

          -- Transition 163 - tr_163
          If (p_152_avail >= 1) and
             (event_rampDOWN_MINUS = '1') and 
             (conv_integer(s_rampDOWNSensor2) = 1) -- guard expr 
          Then
              p_152_avail := p_152_avail - 1;    -- pl_137_2
              p_188_add := p_188_add + 1;   -- pl_188
          End If;

          -- Transition 179 - tr_179
          If (p_172_avail >= 1) and
             (event_rampUP_PLUS = '1')
          Then
              p_172_avail := p_172_avail - 1;    -- pl_172
              p_137_add := p_137_add + 1;   -- pl_137
          End If;

          -- Transition 186 - tr_186
          If (p_188_avail >= 1) and
             (event_rampDOWN_PLUS = '1')
          Then
              p_188_avail := p_188_avail - 1;    -- pl_188
              p_152_add := p_152_add + 1;   -- pl_137_2
          End If;

          -- Transition 197 - tr_197
          If (p_136_avail >= 1) and
             (event_rampUP_MINUS = '1')
          Then
              p_136_avail := p_136_avail - 1;    -- pl_136
              p_167_add := p_167_add + 1;   -- pl_167
          End If;

          -- Transition 209 - tr_209
          If (p_188_avail >= 1) and
             (event_rampDOWNSensor2_MINUS = '1')
          Then
              p_188_avail := p_188_avail - 1;    -- pl_188
              p_167_add := p_167_add + 1;   -- pl_167
          End If;

          -- Transition 214 - tr_214
          If (p_172_avail >= 1) and
             (event_rampUPSensor2_MINUS = '1')
          Then
              p_172_avail := p_172_avail - 1;    -- pl_172
              p_212_add := p_212_add + 1;   -- pl_212
          End If;

          -- Transition 242 - tr_242
          If (p_151_avail >= 1) and
             (event_rampDOWN_MINUS = '1')
          Then
              p_151_avail := p_151_avail - 1;    -- pl_136_2
              p_212_add := p_212_add + 1;   -- pl_212
          End If;

          -- Transition 245 - tr_245
          If (p_34_avail >= 1) and
             (event_arriveIn_MINUS = '1')
          Then
              p_34_avail := p_34_avail - 1;    -- pl_3_3
              p_33_add := p_33_add + 1;   -- pl_2_3
          End If;

          -- Transition 248 - tr_248
          If (p_3_avail >= 1) and
             (event_arriveIn2_MINUS = '1')
          Then
              p_3_avail := p_3_avail - 1;    -- pl_3
              p_2_add := p_2_add + 1;   -- pl_2
          End If;

          -- Transition 6 - tr_6
          If (p_3_avail >= 1) and
             (p_63_avail >= 1) and 
             (conv_integer(s_gotTicket2) = 1) -- guard expr 
          Then
              p_3_avail := p_3_avail - 1;    -- pl_3
              p_63_avail := p_63_avail - 1;    -- pl_26_2
              p_4_add := p_4_add + 1;   -- pl_4
              p_167_add := p_167_add + 1;   -- pl_167
          End If;

          -- Calculate final place marking:
          p_2 <= p_2_avail + p_2_add;
          p_3 <= p_3_avail + p_3_add;
          p_4 <= p_4_avail + p_4_add;
          p_14 <= p_14_avail + p_14_add;
          p_15 <= p_15_avail + p_15_add;
          p_16 <= p_16_avail + p_16_add;
          p_33 <= p_33_avail + p_33_add;
          p_34 <= p_34_avail + p_34_add;
          p_35 <= p_35_avail + p_35_add;
          p_63 <= p_63_avail + p_63_add;
          p_79 <= p_79_avail + p_79_add;
          p_80 <= p_80_avail + p_80_add;
          p_81 <= p_81_avail + p_81_add;
          p_136 <= p_136_avail + p_136_add;
          p_137 <= p_137_avail + p_137_add;
          p_151 <= p_151_avail + p_151_add;
          p_152 <= p_152_avail + p_152_add;
          p_167 <= p_167_avail + p_167_add;
          p_172 <= p_172_avail + p_172_add;
          p_188 <= p_188_avail + p_188_add;
          p_212 <= p_212_avail + p_212_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;

    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
	
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_gateOpenIn1 <= '0';
          s_gateOpenOutFloor1 <= '0';
          s_gateOpenIn2 <= '0';
          s_gateOpenOutFloor2 <= '0';
          s_FreeSpacesTotal <= 0;
          s_TotalCarsFloor1 <= 0;
          s_TotalCarsFloor2 <= 0;

        Elsif Enable='1' Then

          -- Signal gateOpenIn1 default value:
          new_value := 0;

          -- gateOpenIn1 action on place pl_4_3(p_35)
          If p_35 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store gateOpenIn1 and check result range:
          If new_value < 0 Then s_gateOpenIn1 <= '0';
            Elsif new_value > 1 Then s_gateOpenIn1 <= '1';
            Else s_gateOpenIn1 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal gateOpenOutFloor1 default value:
          new_value := 0;

          -- gateOpenOutFloor1 action on place pl_4_2_2(p_81)
          If p_81 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store gateOpenOutFloor1 and check result range:
          If new_value < 0 Then s_gateOpenOutFloor1 <= '0';
            Elsif new_value > 1 Then s_gateOpenOutFloor1 <= '1';
            Else s_gateOpenOutFloor1 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal gateOpenIn2 default value:
          new_value := 0;

          -- gateOpenIn2 action on place pl_4(p_4)
          If p_4 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store gateOpenIn2 and check result range:
          If new_value < 0 Then s_gateOpenIn2 <= '0';
            Elsif new_value > 1 Then s_gateOpenIn2 <= '1';
            Else s_gateOpenIn2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal gateOpenOutFloor2 default value:
          new_value := 0;

          -- gateOpenOutFloor2 action on place pl_4_2(p_16)
          If p_16 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store gateOpenOutFloor2 and check result range:
          If new_value < 0 Then s_gateOpenOutFloor2 <= '0';
            Elsif new_value > 1 Then s_gateOpenOutFloor2 <= '1';
            Else s_gateOpenOutFloor2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal FreeSpacesTotal default value:
          new_value := 71;

          -- FreeSpacesTotal action on place pl_26_2(p_63)
          If p_63 > 0 Then
            exp_res := p_63;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store FreeSpacesTotal and check result range:
          If new_value < 0 Then s_FreeSpacesTotal <= 0;
            Elsif new_value > 71 Then s_FreeSpacesTotal <= 71;
            Else s_FreeSpacesTotal <= new_value;
          End If;
			 
			 --DEFINE
			 std_vector6 <= std_logic_vector(to_unsigned(s_FreeSpacesTotal,8));
			 
			 bcd6 <= to_bcd(std_vector6);
			 s_FreeSpacesAlgTotal_1 <= bcd6(3 downto 0);
			 s_FreeSpacesAlgTotal_2 <= bcd6(7 downto 4);
			 
			 s_OccupiedSpacesTotal <= 71 - s_FreeSpacesTotal;
			 
			 std_vector1 <= std_logic_vector(to_unsigned(s_OccupiedSpacesTotal,8));
			 bcd1 <= to_bcd(std_vector1);
			 s_OccupiedSpacesAlgTotal_1 <= bcd1(3 downto 0);
			 s_OccupiedSpacesAlgTotal_2 <= bcd1(7 downto 4);
			 --
				
          -- Signal TotalCarsFloor1 default value:
          new_value := 0;

          -- TotalCarsFloor1 action on place pl_167(p_167)
          If p_167 > 0 Then
            exp_res := p_167;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store TotalCarsFloor1 and check result range:
          If new_value < 0 Then s_TotalCarsFloor1 <= 0;
            Elsif new_value > 71 Then s_TotalCarsFloor1 <= 71;
            Else s_TotalCarsFloor1 <= new_value;
          End If;

          -- Signal TotalCarsFloor2 default value:
          new_value := 0;

          -- TotalCarsFloor2 action on place pl_212(p_212)
          If p_212 > 0 Then
            exp_res := p_212;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store TotalCarsFloor2 and check result range:
          If new_value < 0 Then s_TotalCarsFloor2 <= 0;
            Elsif new_value > 71 Then s_TotalCarsFloor2 <= 71;
            Else s_TotalCarsFloor2 <= new_value;
          End If;
			 
			 --DEFINE
			 if s_TotalCarsFloor2 < 51 then
				 std_vector2 <= std_logic_vector(to_unsigned(s_TotalCarsFloor2,8));
				 bcd2 <= to_bcd(std_vector2);
				 s_OccupiedSpacesAlgFloor2_1 <= bcd2(3 downto 0);
				 s_OccupiedSpacesAlgFloor2_2 <= bcd2(7 downto 4);
				 
				 s_FreeCarsFloor2 <= 51 - s_TotalCarsFloor2;
				 
				 std_vector3 <= std_logic_vector(to_unsigned(s_FreeCarsFloor2,8));
				 bcd3 <= to_bcd(std_vector3);
				 s_FreeSpacesAlgFloor2_1 <= bcd3(3 downto 0);
				 s_FreeSpacesAlgFloor2_2 <= bcd3(7 downto 4);

			 else 
				 s_FreeSpacesAlgFloor2_1 <= "1111";
				 s_FreeSpacesAlgFloor2_2 <= "1111";
				 s_OccupiedSpacesAlgFloor2_1 <= "1111";
				 s_OccupiedSpacesAlgFloor2_2 <= "1111";
			 end if;
			 --
			 
			 --DEFINE
			 if s_TotalCarsFloor1 < 20 then 
				 std_vector4 <= std_logic_vector(to_unsigned(s_TotalCarsFloor1,8));
				 bcd4 <= to_bcd(std_vector4);
				 s_OccupiedSpacesAlgFloor1_1 <= bcd4(3 downto 0);
				 s_OccupiedSpacesAlgFloor1_2 <= bcd4(7 downto 4);
				 
				 s_FreeCarsFloor1 <= 20 - s_TotalCarsFloor1;
				 
				 std_vector5 <= std_logic_vector(to_unsigned(s_FreeCarsFloor1,8));
				 bcd5 <= to_bcd(std_vector5);
				 s_FreeSpacesAlgFloor1_1 <= bcd5(3 downto 0);
				 s_FreeSpacesAlgFloor1_2 <= bcd5(7 downto 4);
			 else 
				 s_FreeSpacesAlgFloor1_1 <= "1111";
				 s_FreeSpacesAlgFloor1_2 <= "1111";
				 s_OccupiedSpacesAlgFloor1_1 <= "1111";
				 s_OccupiedSpacesAlgFloor1_2 <= "1111";
			 end if;
			 --
			 
			 --para representar o espaco ocupado em percentagem com os LEDS
			 if s_OccupiedSpacesTotal = 0 then
				LEDS <= "00000000";
          elsif s_OccupiedSpacesTotal <= 8 and s_OccupiedSpacesTotal > 0 then
				LEDS <= "00000001";
			 elsif s_OccupiedSpacesTotal <= 17 and s_OccupiedSpacesTotal > 8 then
				LEDS <= "00000011";
			 elsif s_OccupiedSpacesTotal <= 26 and s_OccupiedSpacesTotal > 17 then
				LEDS <= "00000111";
			 elsif s_OccupiedSpacesTotal <= 35 and s_OccupiedSpacesTotal > 26 then
				LEDS <= "00001111";
			 elsif s_OccupiedSpacesTotal <= 44 and s_OccupiedSpacesTotal > 35 then
				LEDS <= "00011111";
			 elsif s_OccupiedSpacesTotal <= 53 and s_OccupiedSpacesTotal > 44 then
				LEDS <= "00111111";
			 elsif s_OccupiedSpacesTotal <= 62 and s_OccupiedSpacesTotal > 53 then
				LEDS <= "01111111";
			 else
				LEDS <= "11111111";
			 end if;
			 
        End If;
      End If;
    End PROCESS;
	
    gateOpenIn1 <= s_gateOpenIn1;
    gateOpenOutFloor1 <= s_gateOpenOutFloor1;
    gateOpenIn2 <= s_gateOpenIn2;
    gateOpenOutFloor2 <= s_gateOpenOutFloor2;
	 
	 FreeSpacesAlgFloor1_1 <= s_FreeSpacesAlgFloor1_1;
	 FreeSpacesAlgFloor1_2 <= s_FreeSpacesAlgFloor1_2;
	 FreeSpacesAlgFloor2_1 <= s_FreeSpacesAlgFloor2_1;
	 FreeSpacesAlgFloor2_2 <= s_FreeSpacesAlgFloor2_2;
	 FreeSpacesAlgTotal_1 <= s_FreeSpacesAlgTotal_1;
	 FreeSpacesAlgTotal_2 <= s_FreeSpacesAlgTotal_2;
	 OccupiedSpacesAlgFloor1_1 <= s_OccupiedSpacesAlgFloor1_1;
	 OccupiedSpacesAlgFloor1_2 <= s_OccupiedSpacesAlgFloor1_2;
	 OccupiedSpacesAlgFloor2_1 <= s_OccupiedSpacesAlgFloor2_1;
	 OccupiedSpacesAlgFloor2_2 <= s_OccupiedSpacesAlgFloor2_2;
	 OccupiedSpacesAlgTotal_1 <= s_OccupiedSpacesAlgTotal_1;
	 OccupiedSpacesAlgTotal_2 <= s_OccupiedSpacesAlgTotal_2;
	 
	 FreeSpacesTotal <= s_FreeSpacesTotal;
    TotalCarsFloor1 <= s_TotalCarsFloor1;
    TotalCarsFloor2 <= s_TotalCarsFloor2;

End Structural;